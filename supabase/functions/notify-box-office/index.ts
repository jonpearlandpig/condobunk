import { createClient } from "https://esm.sh/@supabase/supabase-js@2.49.1";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type, x-supabase-client-platform, x-supabase-client-platform-version, x-supabase-client-runtime, x-supabase-client-runtime-version",
};

async function sendTwilioSms(
  to: string,
  body: string,
  accountSid: string,
  authToken: string,
  from: string,
): Promise<boolean> {
  const url = `https://api.twilio.com/2010-04-01/Accounts/${accountSid}/Messages.json`;
  const credentials = btoa(`${accountSid}:${authToken}`);
  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Authorization": `Basic ${credentials}`,
      "Content-Type": "application/x-www-form-urlencoded",
    },
    body: new URLSearchParams({ To: to, From: from, Body: body }).toString(),
  });
  if (!response.ok) {
    const errText = await response.text();
    console.error("Twilio send error:", response.status, errText);
    return false;
  }
  return true;
}

async function sendResendEmail(
  to: string,
  subject: string,
  html: string,
  apiKey: string,
): Promise<boolean> {
  const response = await fetch("https://api.resend.com/emails", {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${apiKey}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      from: "Condo Bunk TourText <noreply@condobunk.com>",
      to: [to],
      subject,
      html,
    }),
  });
  if (!response.ok) {
    const errText = await response.text();
    console.error("Resend send error:", response.status, errText);
    return false;
  }
  return true;
}

function buildGuestListHtml(
  tourName: string,
  venue: string,
  eventDate: string,
  pickupInstructions: string | null,
  guests: { guest_names: string; ticket_count: number; requester_name: string | null }[],
): string {
  const dateStr = new Date(eventDate + "T00:00:00").toLocaleDateString("en-US", {
    weekday: "long",
    month: "long",
    day: "numeric",
    year: "numeric",
  });

  const totalTickets = guests.reduce((sum, g) => sum + g.ticket_count, 0);

  const rows = guests
    .map(
      (g, i) =>
        `<tr>
          <td style="padding:8px 12px;border-bottom:1px solid #eee;">${i + 1}.</td>
          <td style="padding:8px 12px;border-bottom:1px solid #eee;font-weight:600;">${g.guest_names}</td>
          <td style="padding:8px 12px;border-bottom:1px solid #eee;">${g.ticket_count} ticket${g.ticket_count !== 1 ? "s" : ""}</td>
          <td style="padding:8px 12px;border-bottom:1px solid #eee;color:#666;">${g.requester_name || "—"}</td>
        </tr>`,
    )
    .join("");

  return `
    <div style="font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;max-width:600px;margin:0 auto;padding:24px;">
      <h2 style="margin:0 0 4px;color:#111;">Guest List Update</h2>
      <p style="margin:0 0 20px;color:#555;font-size:14px;">${tourName} — ${venue} — ${dateStr}</p>
      <table style="width:100%;border-collapse:collapse;font-size:14px;">
        <thead>
          <tr style="background:#f5f5f5;">
            <th style="padding:8px 12px;text-align:left;">#</th>
            <th style="padding:8px 12px;text-align:left;">Guest</th>
            <th style="padding:8px 12px;text-align:left;">Tickets</th>
            <th style="padding:8px 12px;text-align:left;">Requested by</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
      <p style="margin:16px 0 4px;font-size:14px;font-weight:600;">Total: ${guests.length} guest${guests.length !== 1 ? "s" : ""}, ${totalTickets} ticket${totalTickets !== 1 ? "s" : ""}</p>
      ${pickupInstructions ? `<p style="margin:4px 0;font-size:13px;color:#555;">Pickup: ${pickupInstructions}</p>` : ""}
      <hr style="border:none;border-top:1px solid #ddd;margin:24px 0 12px;" />
      <p style="margin:0;font-size:11px;color:#999;">Auto-generated by Condo Bunk TourText</p>
    </div>
  `;
}

function buildGuestListSms(
  tourName: string,
  venue: string,
  eventDate: string,
  pickupInstructions: string | null,
  guests: { guest_names: string; ticket_count: number; requester_name: string | null }[],
): string {
  const dateStr = new Date(eventDate + "T00:00:00").toLocaleDateString("en-US", {
    month: "short",
    day: "numeric",
  });
  const totalTickets = guests.reduce((sum, g) => sum + g.ticket_count, 0);
  const lines = guests.map(
    (g) => `${g.guest_names} (${g.ticket_count} tix${g.requester_name ? `, req by ${g.requester_name}` : ""})`,
  );
  let sms = `Guest List - ${tourName} ${venue} ${dateStr}:\n${lines.join("\n")}\nTotal: ${totalTickets} tix.`;
  if (pickupInstructions) sms += ` ${pickupInstructions}`;
  // Trim to ~1500 chars for SMS
  if (sms.length > 1500) sms = sms.slice(0, 1497) + "...";
  return sms;
}

Deno.serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
  const serviceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
  const TWILIO_AUTH_TOKEN = Deno.env.get("TWILIO_AUTH_TOKEN");
  const TWILIO_ACCOUNT_SID = Deno.env.get("TWILIO_ACCOUNT_SID");
  const TWILIO_PHONE_NUMBER = Deno.env.get("TWILIO_PHONE_NUMBER");
  const RESEND_API_KEY = Deno.env.get("RESEND_API_KEY");

  const admin = createClient(supabaseUrl, serviceKey);

  try {
    const { allotment_id } = await req.json();
    if (!allotment_id) {
      return new Response(JSON.stringify({ error: "Missing allotment_id" }), {
        status: 400,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }

    // Get allotment with box office config
    const { data: allotment, error: allotErr } = await admin
      .from("guest_list_allotments")
      .select("*")
      .eq("id", allotment_id)
      .maybeSingle();

    if (allotErr || !allotment) {
      return new Response(JSON.stringify({ error: "Allotment not found" }), {
        status: 404,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }

    if (!allotment.auto_notify_box_office) {
      return new Response(JSON.stringify({ skipped: true, reason: "auto_notify disabled" }), {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }

    const hasEmail = !!allotment.box_office_email;
    const hasPhone = !!allotment.box_office_phone;

    if (!hasEmail && !hasPhone) {
      return new Response(JSON.stringify({ skipped: true, reason: "no box office contact" }), {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }

    // Get all approved requests for this allotment
    const { data: approvedGuests } = await admin
      .from("guest_list_requests")
      .select("guest_names, ticket_count, requester_name")
      .eq("allotment_id", allotment_id)
      .eq("status", "APPROVED")
      .order("created_at", { ascending: true });

    if (!approvedGuests || approvedGuests.length === 0) {
      return new Response(JSON.stringify({ skipped: true, reason: "no approved guests" }), {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }

    // Get tour name
    const { data: tour } = await admin
      .from("tours")
      .select("name")
      .eq("id", allotment.tour_id)
      .maybeSingle();

    const tourName = tour?.name || "Tour";
    const results: { email?: boolean; sms?: boolean } = {};

    // Send email
    if (hasEmail && RESEND_API_KEY) {
      const subject = `Guest List Update - ${tourName} - ${allotment.event_date}`;
      const html = buildGuestListHtml(
        tourName,
        allotment.venue,
        allotment.event_date,
        allotment.pickup_instructions,
        approvedGuests,
      );
      results.email = await sendResendEmail(allotment.box_office_email, subject, html, RESEND_API_KEY);

      // Log outbound
      await admin.from("sms_outbound").insert({
        to_phone: allotment.box_office_email,
        message_text: `[EMAIL] Guest list sent to box office: ${approvedGuests.length} guests`,
        tour_id: allotment.tour_id,
        status: results.email ? "sent" : "failed",
      });
    } else if (hasEmail && !RESEND_API_KEY) {
      console.warn("Box office email configured but RESEND_API_KEY not set");
    }

    // Send SMS
    if (hasPhone && TWILIO_ACCOUNT_SID && TWILIO_AUTH_TOKEN && TWILIO_PHONE_NUMBER) {
      const smsBody = buildGuestListSms(
        tourName,
        allotment.venue,
        allotment.event_date,
        allotment.pickup_instructions,
        approvedGuests,
      );
      results.sms = await sendTwilioSms(
        allotment.box_office_phone,
        smsBody,
        TWILIO_ACCOUNT_SID,
        TWILIO_AUTH_TOKEN,
        TWILIO_PHONE_NUMBER,
      );

      await admin.from("sms_outbound").insert({
        to_phone: allotment.box_office_phone,
        message_text: smsBody,
        tour_id: allotment.tour_id,
        status: results.sms ? "sent" : "failed",
      });
    }

    return new Response(JSON.stringify({ success: true, results }), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error("notify-box-office error:", error);
    return new Response(JSON.stringify({ error: "Internal error" }), {
      status: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }
});
